
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>Conway test</title>

<script type="application/javascript">
// <![CDATA[
// This is an implementation of Conway's Game of Life inside an HTML canvas element.
// Press SPACE to process one step in the game.
// Code by Tony Imbesi, 4/9/2022

// Begin modified code from https://gamedev.cs.gsu.edu/~mweeks/parallax/platformer.html
const INTERVAL = 500;
var useInterval = false;    // Set to true to run the game on a time interval

let canvas;
let ctx;
const MAXCOL = 30;         // dimension of the game board
const MAXROW = 30;  
const CANVASWIDTH = MAXCOL * 32 + 32;
const CANVASHEIGHT = MAXROW * 32 + 32;

let myInterval = null;

var maxAge = 1;       
var ages = [];
var world = [];
var copy = [];

function loadComplete() {
  console.log("Load is complete."); 
  canvas = document.getElementById("theCanvas");
  ctx = canvas.getContext("2d");
  pageLoadComplete = true;
  myInterval = self.setInterval(function(){check4all_loaded()}, 500);
}


var sideLength = 32; // Width and height of each sprite

var pageLoadComplete = false;
var img_loaded = false;
var boxes       = new Image();    // boxes
boxes.src       = "BW.png";

boxes.onload = function() {
  img_loaded = true;
}

// This function is modified from https://www.w3schools.com/js/js_random.asp
/**
 * Gets a random integer in the range [min, max].
 * @param min the minimum number
 * @param max the maximum number
 * @return the random integer
 */
 function getRand(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Begin code from https://gamedev.cs.gsu.edu/~aimbesi1/hw10/platformer.html

class Sprite {
    /**
     * Constructs the sprite.
     * @param {Number} x the initial x position
     * @param {Number} y the initial y position
     * @param {Number} w the width
     * @param {Number} h the height
     * @param {HTMLImageElement} img the image
     * @param {Number} age the age of the tree
     */
    constructor (x, y, w, h, img, age) {
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h;
        this.image = boxes;
        this.age = age;
        this.spriteCol = age * 32;
    }

    /**
     * Update the spriteCol variable based on the tree's age.
     */
    updateSprite() {
        this.spriteCol = this.age * 32;
    }
}

// Begin modified code from https://gamedev.cs.gsu.edu/~mweeks/Qbert_demo.html
// Place boxes

for (var r=0; r<MAXROW; r++) {
      for (var c=0; c<MAXCOL; c++) {
        var rand = getRand(0, maxAge);
        ages.push(rand);
        var spr = new Sprite(c * 32, r * 32, sideLength, sideLength, boxes, rand);
        world.push(spr);
        // console.log("Age added: " + ages[ages.length - 1]);
        // console.log(spr.image.width);
      }
}

// End modified code from https://gamedev.cs.gsu.edu/~mweeks/Qbert_demo.html

// Update each tree in the world with new age values
function updateWorld() {
    for (var i = 0; i < world.length; i++) {
        world[i].age = ages[i];
        world[i].updateSprite();
        // console.log("Ages array:" + ages[i]);
    }
    // console.log('world update: ' + world[world.length - 1].age);
}

/**
 * Use a copy of the ages array to update each tree's age.
 */

function updateAges() {
    copy = [];
    ages.forEach(e => {
        copy.push(e);
    }); // Save a copy of the ages array
    var aliveNeighbors = 0;
    for (var r=0; r<MAXROW; r++) {
      for (var c=0; c<MAXCOL; c++) {
        aliveNeighbors = 0;
        console.log("(" + r + ", " + c + ")");
        // Position of current tree's age: ages[r * MAXROW + c]
        // Count the number of alive neighbors
        if (r > 0) {
            // console.log("Checking upper row for row " + r + ", column " + c);
            
            if (c > 0 && getAgeAt(r - 1, c - 1) > 0) {
                aliveNeighbors++;
                console.log("Top left: " + getAgeAt(r - 1, c - 1));
            }
            
            if (getAgeAt(r - 1, c) > 0) {
                aliveNeighbors++;
                console.log("Top middle: " + getAgeAt(r - 1, c));
            }
            
            if (c < MAXCOL - 1 && getAgeAt(r - 1, c + 1) > 0) {
                aliveNeighbors++;
                console.log("Top right: " + getAgeAt(r - 1, c + 1));
            }
        }
        // console.log("Checking middle row for row " + r + ", column " + c);
        
        if (c > 0 && getAgeAt(r, c - 1) > 0) {
            aliveNeighbors++;
            console.log("Middle left: " + getAgeAt(r, c - 1));
        }
       
        if (c < MAXCOL - 1 && getAgeAt(r, c + 1) > 0) {
            aliveNeighbors++;
            console.log("Middle right: " + getAgeAt(r, c + 1));
        }
            
        if (r < MAXROW - 1) {
            // console.log("Checking lower row for row " + r + ", column " + c);
            
            if (c > 0 && getAgeAt(r + 1, c - 1) > 0) {
                aliveNeighbors++;
                console.log("Bottom left: " + getAgeAt(r + 1, c - 1));
            }
            
            if (getAgeAt(r + 1, c) > 0) {
                aliveNeighbors++;
                console.log("Bottom middle: " + getAgeAt(r + 1, c));
            }
           
            if (c < MAXCOL - 1 && getAgeAt(r + 1, c + 1) > 0) {
                aliveNeighbors++;
                console.log("Bottom right: " + getAgeAt(r + 1, c + 1));
            }
                
        }
        console.log("Total alive neighbors: " + aliveNeighbors);
        // Now update the cell's state based on the number of alive neighbors
        // Each cell with one or no neighbors dies
        if (aliveNeighbors <= 1) {
            ages[r * MAXCOL + c] = 0;
        }
        // Each cell with two neighbors survives
        else if (aliveNeighbors == 2) {
            // Do nothing
        }
        // Each cell with three neighbors becomes populated / survives
        else if (aliveNeighbors == 3) {
            if (copy[r * MAXCOL + c] == 0) {
                // console.log("Cell placed");
                ages[r * MAXCOL + c] = 1;
            }
            else {
                // console.log("Age is not 0: no cell placed");
            }
        }
        // Each cell with four or more neighbors dies
        else if (4 <= aliveNeighbors) {
            ages[r * MAXCOL + c] = 0;
        }
        // Check one cell specifically for debugging
        // if (r == MAXROW - 1 && c == MAXCOL - 1 ) {
        //     console.log('ages array: ' + ages[ages.length - 1]);
        // }
      }
    }
    // ages array should have updated age values based on data from the copied array
}

function getAgeAt(row, column) {
    return copy[row * MAXCOL + column];
}


// Begin code from https://gamedev.cs.gsu.edu/~aimbesi1/hw10/platformer.html

// Erase the entire canvas.
function eraseEverything() {
  ctx.clearRect(0, 0, CANVASWIDTH, CANVASHEIGHT);
}

function drawEverything() {  
  // draw tiles
  var count = 0;
  for (var i = 0; i < world.length; i++) {
      ctx.drawImage(boxes, world[i].spriteCol, 0, sideLength, sideLength, world[i].x, world[i].y, sideLength, sideLength);
      count++;
    //   console.log("Drawing at row " + (world[i].y / 32) + ", column" + (world[i].x / 32));
    //   console.log("Last sprite column: " + world[i].spriteCol);
    //   console.log("Last sprite age: " + world[i].age);
    //   console.log("Compare to: " + ages[i]);
  }
  console.log(count + " vs. " + (MAXROW * MAXCOL));
}

function Tick() {
    eraseEverything();
    updateAges();
    updateWorld();
    drawEverything();
    // clearInterval(myInterval);
}
// whenKeyPressed function modified from HW 9 code
function whenKeyPressed(key) {
    switch (key) {
      case " ":  //  upper-left
        Tick();
      default:
        // console.log(key);
        break;
    }
}
// Loading external resources is asynchronous. 
// We cannot start until everything is loaded.
// This function checks to see that everything loaded.
function check4all_loaded() {
  if (img_loaded && pageLoadComplete) {
    // Everything has loaded.
    // Stop the check-loaded interval
    clearInterval(myInterval); // background color
    eraseEverything();
    drawEverything();
    // Start a game interval
    if (useInterval)
        myInterval = self.setInterval(function(){Tick()}, INTERVAL);
  }
}
// End modified code from https://gamedev.cs.gsu.edu/~mweeks/parallax/platformer.html

// Begin code from HW 9
document['onkeydown'] = function(event) {
    event = event || window.event;

    // event.which is deprecated
    //var key = event.which || event.cursor;
    //whenKeyPressed_old(key);

    var key = event.key;  // This also works, and returns a string
    whenKeyPressed(key);
};
// End code from HW 9
//]]>
</script>

</head>
<body onload="loadComplete()" bgcolor="#000000" text="#ffffff">

<script type="application/javascript">
  // Begin modified code from https://gamedev.cs.gsu.edu/~mweeks/parallax/platformer.html
  document.write('<center>');
  document.write('<canvas id="theCanvas" tabindex="1" width="' + CANVASWIDTH
    + '" height="' + CANVASHEIGHT + '"></canvas>');
  document.write('</center>');
  // End modified code from https://gamedev.cs.gsu.edu/~mweeks/parallax/platformer.html
</script>
</body>
</html>
